package alertmerger

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"sort"
	"time"

	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/lambda"
	"github.com/harishhary/blink/src/shared"
	"github.com/harishhary/blink/src/shared/alert"
	"github.com/harishhary/blink/src/shared/alerttable"
	"github.com/harishhary/blink/src/shared/logger"
	"github.com/harishhary/blink/src/shared/metrics"
)

var log = logger.GetLogger("alertmerger")

type AlertMergeGroup struct {
	alerts []*alert.Alert
}

func NewAlertMergeGroup(a *alert.Alert) *AlertMergeGroup {
	return &AlertMergeGroup{alerts: []*alert.Alert{a}}
}

func (g *AlertMergeGroup) Add(a *alert.Alert) bool {
	if len(g.alerts) >= 50 {
		return false
	}
	if a.CanMerge(g.alerts[0]) {
		g.alerts = append(g.alerts, a)
		return true
	}
	return false
}

type AlertMerger struct {
	table               *alerttable.AlertTable
	alertProc           string
	alertProcTimeout    int
	lambdaClient        *lambda.Lambda
	alertGeneratorLimit int
}

func NewAlertMerger() *AlertMerger {
	sess := session.Must(session.NewSession())
	return &AlertMerger{
		table:               alerttable.NewAlertTable(os.Getenv("ALERTS_TABLE")),
		alertProc:           os.Getenv("ALERT_PROCESSOR"),
		alertProcTimeout:    getEnvInt("ALERT_PROCESSOR_TIMEOUT_SEC", 60),
		lambdaClient:        lambda.New(sess),
		alertGeneratorLimit: 5000,
	}
}

func (am *AlertMerger) getAlertGenerator(ruleName string) chan *alert.Alert {
	out := make(chan *alert.Alert)
	go func() {
		defer close(out)
		generator := am.table.GetAlertRecords(ruleName, am.alertProcTimeout)
		idx := 0
		for record := range generator {
			if idx >= am.alertGeneratorLimit {
				log.Warningf("Alert Merger reached alert limit of %d for rule \"%s\"", am.alertGeneratorLimit, ruleName)
				return
			}
			alert, err := alert.CreateFromDynamoRecord(record)
			if err != nil {
				log.Errorf("Invalid alert record %s: %v", record, err)
				continue
			}
			out <- alert
			idx++
		}
	}()
	return out
}

func (am *AlertMerger) mergeGroups(alerts []*alert.Alert) []*AlertMergeGroup {
	var mergeGroups []*AlertMergeGroup
	sort.Slice(alerts, func(i, j int) bool {
		return alerts[i].Created.Before(alerts[j].Created)
	})
	for _, alert := range alerts {
		added := false
		for _, group := range mergeGroups {
			if group.Add(alert) {
				added = true
				break
			}
		}
		if !added {
			if time.Now().Before(alert.Created.Add(alert.MergeWindow)) {
				break
			}
			mergeGroups = append(mergeGroups, NewAlertMergeGroup(alert))
		}
	}
	return mergeGroups
}

func (am *AlertMerger) dispatchAlert(a *alert.Alert) {
	a.Attempts++
	log.Infof("Dispatching %s to %s (attempt %d)", a, am.alertProc, a.Attempts)
	metrics.LogMetric(metrics.ALERT_MERGER_NAME, metrics.ALERT_ATTEMPTS, a.Attempts)

	recordPayload, _ := json.Marshal(a.DynamoRecord())

	payload := recordPayload
	if len(recordPayload) > 126000 {
		payload, _ = json.Marshal(a.DynamoKey)
	}

	am.lambdaClient.Invoke(&lambda.InvokeInput{
		FunctionName:   aws.String(am.alertProc),
		InvocationType: aws.String("Event"),
		Payload:        payload,
		Qualifier:      aws.String("production"),
	})

	a.Dispatched = time.Now()
	am.table.MarkAsDispatched(a)
}

func (am *AlertMerger) Dispatch() {
	var mergedAlerts []*alert.Alert
	var alertsToDelete []*alert.Alert

	for ruleName := range am.table.RuleNamesGenerator() {
		var mergeEnabledAlerts []*alert.Alert
		for alert := range am.getAlertGenerator(ruleName) {
			if len(alert.RemainingOutputs) > 0 {
				am.dispatchAlert(alert)
			} else if alert.MergeEnabled {
				mergeEnabledAlerts = append(mergeEnabledAlerts, alert)
			} else {
				alertsToDelete = append(alertsToDelete, alert)
			}
		}

		for _, group := range am.mergeGroups(mergeEnabledAlerts) {
			newAlert := alert.Merge(group.alerts)
			log.Infof("Merged %d alerts into a new alert with ID %s", len(group.alerts), newAlert.AlertID)
			mergedAlerts = append(mergedAlerts, newAlert)
			alertsToDelete = append(alertsToDelete, group.alerts...)
		}
	}

	if len(mergedAlerts) > 0 {
		am.table.AddAlerts(mergedAlerts)
		for _, alert := range mergedAlerts {
			am.dispatchAlert(alert)
		}
	}

	if len(alertsToDelete) > 0 {
		var keys [][]interface{}
		for _, alert := range alertsToDelete {
			keys = append(keys, []interface{}{alert.RuleName, alert.AlertID})
		}
		am.table.DeleteAlerts(keys)
	}
}

func Handler(ctx context.Context, event events.CloudWatchEvent) {
	NewAlertMerger().Dispatch()
}

func main() {
	lambda.Start(Handler)
}
